# Database Schema Design

_Documentation for Riichi Mahjong League database architecture_

## Overview

This database design follows a **source vs. derived tables** philosophy with a **configuration-driven rating system**. Source tables contain season-agnostic game data, while derived tables are computed based on flexible configurations that users can experiment with in real-time.

## Design Philosophy

### Source Tables (Critical Data)

- **Human-recorded** during/after games
- **Season-agnostic** - no embedded configuration parameters
- **Must be preserved** - contains irreplaceable game logs
- **Minimal computed fields** - mostly raw data entry
- **Recovery impossible** if lost

### Derived Tables (Computed Cache)

- **Generated by Python function** using configuration parameters
- **Can be regenerated** if deleted
- **Performance optimization** - hash-based caching system
- **Configuration-driven** - different configs produce different results

### Configuration System (Phase 0.5)

- **Hash-based caching** - configurations identified by content hash
- **Smart cache invalidation** - detects when source data changes
- **User experimentation** - players can test different rule sets
- **Official seasons** - admin-controlled configurations for competitions

---

## Source Tables (Season-Agnostic Data)

### Core Entities

#### Players

```sql
create table players (
  id              uuid primary key default uuid_generate_v4(),
  display_name    text unique not null,
  auth_user_id    uuid unique references auth.users(id) on delete set null,

  -- Contact info for scheduling
  email           text,
  phone           text,
  timezone        text default 'America/Los_Angeles',

  -- Preferences
  notification_preferences jsonb default '{"email": true, "push": true}',

  created_at      timestamptz default now(),
  updated_at      timestamptz default now()
);
```

#### Games (Configuration-Agnostic)

```sql
create table games (
  id              uuid primary key default uuid_generate_v4(),

  -- Game timing (no season reference - determined at query time)
  started_at      timestamptz not null,
  finished_at     timestamptz,
  status          game_status default 'ongoing',

  -- Scheduling (Phase 2)
  scheduled_at    timestamptz,
  table_type      table_type default 'automatic',
  location        text default 'Host House',

  notes           text,
  created_at      timestamptz default now(),
  updated_at      timestamptz default now()
);

create index idx_games_finished_at on games(finished_at);
create index idx_games_status on games(status);
```

#### Game Seats

```sql
create table game_seats (
  game_id         uuid references games(id) on delete cascade,
  seat            riichi_seat not null,
  player_id       uuid references players(id) on delete restrict,
  final_score     integer,  -- Raw final score (e.g., 48100), null if ongoing

  primary key (game_id, seat),
  unique (game_id, player_id)
);
```

### Hand-by-Hand Tracking (Phase 1)

#### Hand Events

```sql
create table hand_events (
  id               uuid primary key default uuid_generate_v4(),
  game_id          uuid references games(id) on delete cascade,
  hand_seq         smallint not null,
  seat             riichi_seat not null,
  event_type       event_type not null,
  riichi_declared  boolean not null default false,
  points_delta     integer not null,
  pot_delta        integer not null default 0,
  round_kanji      char(1) not null check (round_kanji in ('E','S','W','N')),
  kyoku            smallint not null check (kyoku between 1 and 4),
  honba            smallint not null,
  details          jsonb not null default '{}',
  created_at       timestamptz default now(),

  unique (game_id, hand_seq, seat)
);
```

### Enumerated Types

```sql
-- Wind assignments (physical seating positions)
create type riichi_seat as enum ('east','south','west','north');

-- Hand outcomes
create type event_type as enum (
  'tsumo',           -- self‑draw win
  'ron',             -- win on discard
  'draw',            -- exhaustive draw (流局 ryūkyoku)
  'abortive_draw',   -- abortive draw (途中流局 tochuu ryuukyoku)
  'chombo'           -- penalty hand
);

-- Game lifecycle
create type game_status as enum ('scheduled','ongoing','finished','cancelled');

-- Table assignments
create type table_type as enum ('automatic','manual');
```

---

## Configuration System (Phase 0.5)

### Rating Configurations

```sql
create table rating_configurations (
  config_hash     text primary key,  -- SHA-256 of config JSON
  config_data     jsonb not null,    -- The actual configuration
  name            text,              -- e.g., "Winter 2024", "Experimental High Stakes"
  description     text,              -- Human-readable description
  is_official     boolean default false,  -- Admin-controlled official seasons
  created_by      uuid references players(id),  -- Who created this config
  created_at      timestamptz default now(),
  last_used_at    timestamptz default now()
);

create index idx_rating_configs_official on rating_configurations(is_official, last_used_at);
create index idx_rating_configs_creator on rating_configurations(created_by, created_at);
```

### Configuration Structure (JSONB)

```typescript
interface RatingConfiguration {
  // Time bounds (replaces season table)
  timeRange: {
    startDate: string; // "2024-01-01"
    endDate: string; // "2024-03-31"
    name: string; // "Winter 2024"
  };

  // Rating system parameters
  rating: {
    initialMu: number; // 25.0
    initialSigma: number; // 8.33
    confidenceFactor: number; // 2.0 (for display rating = μ - k*σ)
    decayRate: number; // 0.02 (weekly sigma inflation)
  };

  // Scoring system
  scoring: {
    oka: number; // 20000 (return bonus)
    uma: [number, number, number, number]; // [10000, 5000, -5000, -10000]
  };

  // Weight calculation for margin-of-victory
  weights: {
    divisor: number; // 40 (plus-minus scaling factor)
    min: number; // 0.5 (minimum weight)
    max: number; // 1.5 (maximum weight)
  };

  // Qualification rules
  qualification: {
    minGames: number; // 8 (games needed for prizes)
    dropWorst: number; // 2 (safety net for bad games)
  };
}
```

---

## Derived Tables (Configuration-Driven Cache)

### Cached Player Ratings

```sql
create table cached_player_ratings (
  config_hash     text references rating_configurations(config_hash),
  player_id       uuid references players(id),

  -- Time bounds for this calculation
  games_start_date date not null,
  games_end_date   date not null,

  -- OpenSkill parameters (computed by Python)
  mu              numeric(8,4) not null,
  sigma           numeric(8,4) not null,
  display_rating  numeric(8,2) not null,  -- μ - k*σ

  -- Game statistics (computed by Python)
  games_played    integer default 0,
  total_plus_minus integer default 0,
  best_game_plus  integer,
  worst_game_minus integer,

  -- Streak tracking (computed by Python)
  longest_first_streak integer default 0,
  longest_fourth_free_streak integer default 0,

  -- Decay tracking
  last_game_date  timestamptz,
  last_decay_applied timestamptz,

  -- Performance statistics (computed by Python)
  tsumo_rate      numeric(5,4),   -- % of hands won by tsumo
  ron_rate        numeric(5,4),   -- % of hands won by ron
  riichi_rate     numeric(5,4),   -- % of hands with riichi declared
  deal_in_rate    numeric(5,4),   -- % of hands where dealt into others

  -- Cache metadata
  computed_at     timestamptz default now(),
  source_data_hash text not null,  -- Hash of input game data for cache invalidation

  primary key (config_hash, player_id, games_start_date, games_end_date)
);

create index idx_cached_ratings_config on cached_player_ratings(config_hash, display_rating desc);
create index idx_cached_ratings_player on cached_player_ratings(player_id, computed_at);
```

### Cached Game Results

```sql
create table cached_game_results (
  config_hash     text references rating_configurations(config_hash),
  game_id         uuid references games(id),
  player_id       uuid references players(id),
  seat            riichi_seat not null,

  -- Computed by Python function using configuration
  final_score     integer not null,
  placement       integer not null check (placement between 1 and 4),
  plus_minus      integer not null,  -- oka/uma applied per config
  rating_weight   numeric(4,2),     -- for OpenSkill calculation

  -- Rating changes from this game
  mu_before       numeric(8,4),
  sigma_before    numeric(8,4),
  mu_after        numeric(8,4),
  sigma_after     numeric(8,4),

  -- Cache metadata
  computed_at     timestamptz default now(),

  primary key (config_hash, game_id, player_id),
  unique (config_hash, game_id, seat)
);

create index idx_cached_game_results_player on cached_game_results(config_hash, player_id, computed_at);
```

### Current Leaderboard (Dynamic View)

```sql
create view current_leaderboard as
select
  p.display_name,
  cpr.display_rating,
  cpr.games_played,
  rc.config_data->>'qualification'->>'minGames' as min_games_qualify,
  cpr.games_played >= (rc.config_data->'qualification'->>'minGames')::integer as qualified,
  cpr.total_plus_minus,
  round(cpr.total_plus_minus::numeric / greatest(cpr.games_played, 1), 1) as avg_plus_minus,
  cpr.tsumo_rate,
  cpr.ron_rate,
  cpr.riichi_rate,
  cpr.deal_in_rate,
  cpr.longest_first_streak,
  cpr.longest_fourth_free_streak,
  cpr.last_game_date,

  -- Activity status (computed real-time)
  case
    when cpr.last_game_date < now() - interval '14 days' then 'inactive'
    when cpr.last_game_date < now() - interval '7 days' then 'idle'
    else 'active'
  end as activity_status,

  -- Configuration info
  rc.name as season_name,
  rc.is_official

from cached_player_ratings cpr
join players p on p.id = cpr.player_id
join rating_configurations rc on rc.config_hash = cpr.config_hash
where rc.is_official = true  -- Show official season by default
order by cpr.display_rating desc;
```

---

## Data Flow & Responsibilities

### Python Function Responsibilities

The Python OpenSkill function handles all rating calculations with configuration-driven logic:

1. **Configuration Loading**: Parse and validate rating configuration parameters
2. **Cache Management**: Check for cache hits using config hash and source data hash
3. **Rating Updates**: Calculate μ, σ, and display_rating using configuration parameters
4. **Statistics Generation**: Compute all performance metrics and streaks
5. **Weight Calculation**: Apply margin-of-victory weights based on configuration
6. **Decay Processing**: Apply time-based rating decay for inactive players
7. **Data Validation**: Ensure game results consistency and handle edge cases

### Configuration-Driven Flow

```python
def get_ratings_for_config(config: RatingConfiguration) -> Dict[str, PlayerRating]:
    """Main entry point for configuration-driven rating calculation."""

    # 1. Generate configuration hash
    config_hash = generate_config_hash(config)

    # 2. Get source games for time range
    games = get_games_in_range(config.timeRange.startDate, config.timeRange.endDate)
    source_data_hash = generate_source_data_hash(games)

    # 3. Check cache
    cached_ratings = get_cached_ratings(config_hash, source_data_hash)
    if cached_ratings:
        return cached_ratings  # Cache hit!

    # 4. Compute new ratings using configuration
    new_ratings = compute_ratings_with_config(games, config)

    # 5. Store in cache
    store_cached_ratings(config_hash, new_ratings, source_data_hash)

    return new_ratings
```

### Smart Caching System

- **Configuration Hash**: SHA-256 of complete configuration JSON (sorted keys)
- **Source Data Hash**: SHA-256 of relevant game data (IDs, timestamps, scores)
- **Cache Invalidation**: Automatic when source games change
- **Cache Warming**: Pre-compute popular configuration combinations
- **Cache Cleanup**: Remove unused configurations after 30 days

### Database Triggers & Webhooks

- **Game Completion**: Invalidate cache entries that include the new game
- **Configuration Changes**: Mark affected cache entries for recomputation
- **Data Consistency**: Foreign key constraints prevent orphaned records
- **Performance Monitoring**: Track cache hit rates and computation times

### Wind Rotation & Seat Tracking

```sql
-- Helper query to derive current dealer/wind positions
select
  gs.seat as physical_seat,
  gs.player_id,
  -- Initial wind assignment stays constant
  gs.seat as initial_wind,
  -- Current wind rotates with dealer
  case
    when mod((hand_seq - 1) + case when gs.seat = 'east' then 0
                                  when gs.seat = 'south' then 1
                                  when gs.seat = 'west' then 2
                                  when gs.seat = 'north' then 3 end, 4) = 0 then 'east'
    when mod((hand_seq - 1) + case when gs.seat = 'east' then 0
                                  when gs.seat = 'south' then 1
                                  when gs.seat = 'west' then 2
                                  when gs.seat = 'north' then 3 end, 4) = 1 then 'south'
    when mod((hand_seq - 1) + case when gs.seat = 'east' then 0
                                  when gs.seat = 'south' then 1
                                  when gs.seat = 'west' then 2
                                  when gs.seat = 'north' then 3 end, 4) = 2 then 'west'
    else 'north'
  end as current_wind
from game_seats gs
cross join (select hand_seq from hand_events where game_id = gs.game_id order by hand_seq desc limit 1) he;
```

---

## Phase 2: Scheduling System

### Player Availability

```sql
create table player_availability (
  id              uuid primary key default uuid_generate_v4(),
  player_id       uuid references players(id) on delete cascade,
  start_time      timestamptz not null,
  end_time        timestamptz not null,
  is_recurring    boolean default false,
  recurrence_rule text,
  preference      integer default 5 check (preference between 1 and 10),
  notes           text,
  created_at      timestamptz default now(),

  check (end_time > start_time)
);
```

---

## Key Design Decisions

1. **Source/Derived Separation**: Critical game data is preserved while performance caches can be regenerated
2. **Configuration-Driven Logic**: All rating calculations are parameterized by configuration
3. **Season-Agnostic Source Data**: Games have no embedded configuration, enabling flexible experimentation
4. **Hash-Based Caching**: Smart cache invalidation based on configuration and source data changes
5. **User Experimentation**: Players can test different rule sets without affecting official ratings
6. **Wind Tracking**: Physical seats remain constant, logical winds rotate with play
7. **Comprehensive Events**: Single `hand_events` table handles all game outcomes
8. **Performance Optimized**: Cached derived tables provide instant configuration switching

### Configuration vs. Traditional Season Approach

| Aspect              | Configuration-Driven                 | Traditional Season Table       |
| ------------------- | ------------------------------------ | ------------------------------ |
| **Flexibility**     | Unlimited rule experimentation       | Fixed rules per season         |
| **User Engagement** | Interactive "what-if" scenarios      | Static leaderboard             |
| **Performance**     | Smart caching with instant switching | Requires recalculation         |
| **Data Integrity**  | Source data remains pure             | Rules embedded in data         |
| **Development**     | Rule changes via config files        | Database migrations            |
| **Scalability**     | Handles infinite configurations      | Limited to pre-defined seasons |

This schema supports all project phases while enabling unprecedented flexibility for rating system experimentation and user engagement.
